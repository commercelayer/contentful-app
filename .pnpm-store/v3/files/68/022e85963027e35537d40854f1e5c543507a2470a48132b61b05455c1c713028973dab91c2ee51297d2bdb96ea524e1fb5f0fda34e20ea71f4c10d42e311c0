import $hYGFM$react, {useState as $hYGFM$useState, useEffect as $hYGFM$useEffect, useCallback as $hYGFM$useCallback, useMemo as $hYGFM$useMemo} from "react";
import {useId as $hYGFM$useId, mergeRefs as $hYGFM$mergeRefs} from "@contentful/f36-core";
import {usePopper as $hYGFM$usePopper} from "react-popper";
import {cx as $hYGFM$cx, css as $hYGFM$css} from "emotion";
import {Portal as $hYGFM$Portal} from "@contentful/f36-utils";
import $hYGFM$contentfulf36tokens from "@contentful/f36-tokens";




const $8c1b76e1106abdf5$var$PopoverContext = $hYGFM$react.createContext(undefined);
const $8c1b76e1106abdf5$export$1468d0761b26e6c8 = ()=>{
    const context = $hYGFM$react.useContext($8c1b76e1106abdf5$var$PopoverContext);
    if (context === undefined) throw new Error('usePopoverContext must be used within a PopoverContextProvider');
    return context;
};
const $8c1b76e1106abdf5$export$f5300fbf692a63ec = $8c1b76e1106abdf5$var$PopoverContext.Provider;



function $fd548c9231cfa260$export$5b6b19405a83ff9d(props) {
    const { children: children , isOpen: isOpen , placement: placement = 'bottom-start' , isFullWidth: isFullWidth = false , isAutoalignmentEnabled: isAutoalignmentEnabled = true , usePortal: usePortal = true , closeOnBlur: closeOnBlur = true , closeOnEsc: closeOnEsc = true , onClose: onClose , autoFocus: autoFocus = true , id: id , offset: offset = [
        1,
        4
    ] , renderOnlyWhenOpen: renderOnlyWhenOpen = true  } = props;
    const [triggerElement, setTriggerElement] = $hYGFM$useState(null);
    const [popoverElement, setPopoverElement] = $hYGFM$useState(null);
    const { attributes: popperAttributes , update: update , styles: popperStyles  } = $hYGFM$usePopper(triggerElement, popoverElement, {
        placement: placement,
        modifiers: [
            {
                name: 'offset',
                options: {
                    offset: offset
                }
            },
            {
                ...$fd548c9231cfa260$var$sameWidth,
                enabled: isFullWidth
            },
            {
                name: 'preventOverflow',
                enabled: isAutoalignmentEnabled,
                options: {
                    mainAxis: true
                }
            },
            {
                name: 'flip',
                enabled: isAutoalignmentEnabled
            }
        ]
    });
    $hYGFM$useEffect(()=>{
        if (isOpen && autoFocus && popoverElement) popoverElement.focus({
            preventScroll: true
        });
         // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        isOpen,
        popoverElement
    ]);
    $hYGFM$useEffect(()=>{
        const updatePosition = async ()=>{
            if (isOpen && update) await update();
        };
        updatePosition();
    }, [
        isOpen,
        update
    ]);
    const popoverGeneratedId = $hYGFM$useId(undefined, 'popover-content');
    const popoverId = id || popoverGeneratedId;
    const closeAndFocusTrigger = $hYGFM$useCallback(()=>{
        onClose === null || onClose === void 0 ? void 0 : onClose(); // setTimeout trick to make it work with focus-lock
        setTimeout(()=>{
            return triggerElement === null || triggerElement === void 0 ? void 0 : triggerElement.focus({
                preventScroll: true
            });
        }, 0);
    }, [
        onClose,
        triggerElement
    ]);
    const contextValue = $hYGFM$useMemo(()=>{
        return {
            isOpen: Boolean(isOpen),
            usePortal: usePortal,
            renderOnlyWhenOpen: renderOnlyWhenOpen,
            getTriggerProps: (_ref = null)=>({
                    ref: $hYGFM$mergeRefs(setTriggerElement, _ref),
                    ['aria-expanded']: Boolean(isOpen),
                    ['aria-controls']: popoverId
                })
            ,
            getPopoverProps: (_props = {}, _ref = null)=>{
                return {
                    ...popperAttributes.popper,
                    style: {
                        ..._props.style || {},
                        ...popperStyles.popper
                    },
                    ref: $hYGFM$mergeRefs(setPopoverElement, _ref),
                    id: popoverId,
                    onBlur: (event)=>{
                        if (_props.onBlur) _props.onBlur(event);
                        if (!closeOnBlur) return;
                        const relatedTarget = event.relatedTarget;
                        const targetIsPopover = popoverElement === relatedTarget || (popoverElement === null || popoverElement === void 0 ? void 0 : popoverElement.contains(relatedTarget));
                        const targetIsTrigger = triggerElement === relatedTarget || (triggerElement === null || triggerElement === void 0 ? void 0 : triggerElement.contains(relatedTarget));
                        if (targetIsPopover || targetIsTrigger) return;
                        onClose === null || onClose === void 0 ? void 0 : onClose();
                    },
                    onKeyDown: (event)=>{
                        if (_props.onKeyDown) _props.onKeyDown(event);
                        if (closeOnEsc && event.key === 'Escape') closeAndFocusTrigger();
                    }
                };
            }
        };
    }, [
        isOpen,
        renderOnlyWhenOpen,
        popperAttributes,
        popperStyles,
        usePortal,
        popoverId,
        closeOnEsc,
        closeOnBlur,
        popoverElement,
        triggerElement,
        closeAndFocusTrigger,
        onClose
    ]);
    return /*#__PURE__*/ $hYGFM$react.createElement($8c1b76e1106abdf5$export$f5300fbf692a63ec, {
        value: contextValue
    }, children);
}
/**
 * Sets the popover width to the size of the trigger element.
 */ const $fd548c9231cfa260$var$sameWidth = {
    name: 'sameWidth',
    enabled: true,
    phase: 'beforeWrite',
    requires: [
        'computeStyles'
    ],
    fn: ({ state: state  })=>{
        state.styles.popper.width = `${state.rects.reference.width}px`;
    },
    effect: ({ state: state  })=>()=>{
            const reference = state.elements.reference;
            state.elements.popper.style.width = `${reference.offsetWidth}px`;
        }
};








const $8a165eef2449d46a$export$fbd764fe961047f7 = (isOpen)=>({
        container: /*#__PURE__*/ $hYGFM$css({
            display: isOpen ? 'initial' : 'none',
            background: $hYGFM$contentfulf36tokens.colorWhite,
            border: 0,
            borderRadius: $hYGFM$contentfulf36tokens.borderRadiusMedium,
            boxShadow: $hYGFM$contentfulf36tokens.boxShadowDefault,
            zIndex: $hYGFM$contentfulf36tokens.zIndexDropdown,
            '&:focus': {
                boxShadow: $hYGFM$contentfulf36tokens.glowPrimary,
                outline: 'none'
            },
            '&:focus:not(:focus-visible)': {
                boxShadow: $hYGFM$contentfulf36tokens.boxShadowDefault
            }
        })
    })
;


const $249e5486684b1d2a$var$_PopoverContent = (props, ref)=>{
    const { children: children , className: className , testId: testId = 'cf-ui-popover-content' , role: role = 'dialog' , ...otherProps } = props;
    const { isOpen: isOpen , renderOnlyWhenOpen: renderOnlyWhenOpen , getPopoverProps: getPopoverProps , usePortal: usePortal  } = $8c1b76e1106abdf5$export$1468d0761b26e6c8();
    const styles = $8a165eef2449d46a$export$fbd764fe961047f7(isOpen);
    const content = /*#__PURE__*/ $hYGFM$react.createElement("div", {
        ...otherProps,
        ...getPopoverProps(otherProps, ref),
        className: $hYGFM$cx(styles.container, className),
        "data-test-id": testId,
        tabIndex: -1,
        role: role,
        // for internal contentful apps usage
        "data-position-absolute": true
    }, children);
    if (renderOnlyWhenOpen && !isOpen) return null;
    return usePortal ? /*#__PURE__*/ $hYGFM$react.createElement($hYGFM$Portal, null, content) : content;
};
const $249e5486684b1d2a$export$d7e1f420b25549ff = /*#__PURE__*/ $hYGFM$react.forwardRef($249e5486684b1d2a$var$_PopoverContent);




const $2ab55052da688660$export$7dacb05d26466c3 = (props)=>{
    const child = $hYGFM$react.Children.only(props.children);
    const { getTriggerProps: getTriggerProps  } = $8c1b76e1106abdf5$export$1468d0761b26e6c8();
    var ref;
    return /*#__PURE__*/ $hYGFM$react.cloneElement(child, {
        ...getTriggerProps(child.ref),
        'aria-haspopup': (ref = child.props['aria-haspopup']) !== null && ref !== void 0 ? ref : 'dialog'
    });
};


const $52a0de85cb27ef74$export$5b6b19405a83ff9d = $fd548c9231cfa260$export$5b6b19405a83ff9d;
$52a0de85cb27ef74$export$5b6b19405a83ff9d.Content = $249e5486684b1d2a$export$d7e1f420b25549ff;
$52a0de85cb27ef74$export$5b6b19405a83ff9d.Trigger = $2ab55052da688660$export$7dacb05d26466c3;






export {$52a0de85cb27ef74$export$5b6b19405a83ff9d as Popover, $2ab55052da688660$export$7dacb05d26466c3 as PopoverTrigger, $249e5486684b1d2a$export$d7e1f420b25549ff as PopoverContent};
//# sourceMappingURL=module.js.map
